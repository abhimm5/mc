<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time WebRTC Chat</title>
    <link href='https://fonts.googleapis.com/css?family=Outfit' rel='stylesheet'>
    <style>
        body {
            font-family: 'Outfit'; font-size: 22px;
            margin: 0;
            padding: 0;
            height: 100vh;
            background: #e9e9e9;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            flex-direction: column;
        }

        #messages {
            font-size: 30px;
            padding: 20px;
            text-align: center;
            overflow-y: auto;
            max-height: 70vh;
            width: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .message {
            margin-bottom: 12px;
            padding: 12px;
            max-width: 90%;
            font-size: 40px;
            color: white;
            opacity: 0;
            display: inline-block;
            width: 0;
            overflow: hidden;
            transition: width 1s ease-out, opacity 1s ease-out;
        }

        .message.you {
            text-align: center;
            color: black;
        }

        .message.peer {
            text-align: center;
            color: black;
        }

        /* Fade-in effect for the last word */
        .fade-in-text {
            animation: fadeInEffect 3s forwards;
        }

        @keyframes fadeInEffect {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }

      #messageInput {
    font-family: 'Outfit', sans-serif;
    font-size: 40px;
    padding: 20px;
    width: 100%;
    max-width: 600px;
    min-height: 50px;
    border: 1px solid #ccc;
    border-radius: 5px;
    outline: none;
    box-sizing: border-box; /* Ensure padding is included in width/height calculation */
    word-wrap: break-word; /* Ensure long words wrap */
    word-break: break-word; /* Prevent word overflow */
    white-space: normal; /* Allow text wrapping */
    overflow-wrap: break-word; /* Break long words when necessary */
    overflow-x: hidden; /* Prevent horizontal overflow */
    line-height: 1.5;
    text-align: left; /* Left-align text */
    display: block; /* Block-level behavior */
    justify-content: center;
            align-items: center;
            text-align: center;
            color: #F0513E;
}

/* Ensure divs inside contenteditable appear inline */
#messageInput div {
    display: inline-block; /* Make divs inline-block to sit next to each other */
    margin: 0; /* Remove any default margin */
    padding: 0; /* Remove default padding */
    white-space: nowrap; /* Prevent breaking between divs */
}

/* When the contenteditable div is empty, show placeholder */
#messageInput:empty:before {
    content: attr(placeholder);
    color: #888;
    font-size: 40px;
    font-family: 'Outfit', sans-serif;
}

        /* Word container */
        .word {
            display: inline-block;
        }

    .gray-text {
      color: #F0513E;
    }

    .black-text {
      color: black;
    }
    </style>
</head>
<body>
    <h5 id="user" style="color:#333; text-align: center;">Real-Time WebRTC Chat</h5>
    <div id="messageInput" contenteditable="true" placeholder="Type a message..."></div>
    <h6 style="color:#888; text-align: center;">Use full stop to send all texts.<br>Press enter to clear chats after every msgs.</h6>
    <br>




    <script src="/socket.io/socket.io.js"></script>
<script>
    const socket = io(); // Connect to the signaling server
    const peerConnection = new RTCPeerConnection();
    let dataChannel;
    const messageInput = document.getElementById("messageInput");
    const wordDivElement = document.createElement('div');
    const user = document.getElementById("user");

    let previousMessage = ''; // Keep track of the previous message

    // Function to send an emoji as a message
    function sendEmoji(emoji) {
        displayMessage(emoji, 'you'); // Show message locally
        socket.emit('chatMessage', emoji); // Emit to the server
    }

    // Attach event listeners to all emoji elements
    document.querySelectorAll('div span[style*="font-size:50px"]').forEach(emoji => {
        emoji.addEventListener('click', () => {
            sendEmoji(emoji.textContent);
        });
    });

    // Display or update a message in the input field
    function displayMessage(message, sender) {
        if (sender === 'peer') {
            // Clear the content before adding the new message
            messageInput.innerHTML = '';

            // Split the message into words, maintaining spaces
            const words = message.split(' ');

            // Loop through words to create the message with space and fade-in effect for the last word
            words.forEach((word, index) => {
                const wordElement = document.createElement('div');
                wordElement.textContent = word;
                wordElement.style.color = "#222";

                // Apply fade-in effect to the last word only
                if (index === words.length - 1) {
                    wordElement.classList.add('fade-in-text');
                }

                // Append each word to the input container
                messageInput.appendChild(wordElement);

                // Add space (HTML entity) as a separate <span> after each word except the last one
                if (index < words.length - 1) {
                    const spaceElement = document.createElement('div');
                    spaceElement.innerHTML = '&nbsp;'; // Add non-breaking space using innerHTML
                    messageInput.appendChild(spaceElement);
                    spaceElement.style.color = "#222";
                }
            });
            user.innerHTML = "They:"
        }

        if (sender === 'you') {

            user.innerHTML = "You:"
        }


    }

    // Create the data channel for WebRTC messaging
    function createDataChannel() {
        dataChannel = peerConnection.createDataChannel("chat");
        dataChannel.onopen = () => console.log("Data channel open.");
        dataChannel.onmessage = (event) => displayMessage(event.data, 'peer');
    }

    // Emit message when user types
    messageInput.addEventListener('keydown', (e) => {
        let message = messageInput.textContent.trim();
        if (message && (e.key === '?' || e.key === '!' || e.key === '.' || e.key === ' ')) {
            if (message !== previousMessage) {
                if (e.key === '.') {
                    message = message.trim() + ".";
                    displayMessage(message, 'you');
                    socket.emit('chatMessage', message);
                } else if (e.key === '?') {
                    message = message.trim() + "?";
                    displayMessage(message, 'you');
                    socket.emit('chatMessage', message);
                } else if (e.key === '!') {
                    message = message.trim() + "!";
                    displayMessage(message, 'you');
                    socket.emit('chatMessage', message);
                } else if (e.key === ' ') {
                    displayMessage(message, 'you');
                    socket.emit('chatMessage', message);
                }
                previousMessage = message;
            }
        }
    });

    // Clear messages when "Enter" is pressed
    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            messageInput.textContent = '';
            previousMessage = '';
            socket.emit('clearMessage');
        }
    });

    // WebRTC signaling logic
    socket.on("offer", (offer) => {
        peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        createDataChannel();
        peerConnection.createAnswer().then((answer) => {
            peerConnection.setLocalDescription(answer);
            socket.emit("answer", answer);
        });
    });

    socket.on("answer", (answer) => {
        peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
    });

    socket.on("candidate", (candidate) => {
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    });

    peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
            socket.emit("candidate", event.candidate);
        }
    };

    // Start WebRTC connection
    function initiateConnection() {
        peerConnection.createOffer().then((offer) => {
            peerConnection.setLocalDescription(offer);
            socket.emit("offer", offer);
        });
    }

    window.onload = initiateConnection;

    // Listen for chat messages from the other peer
    socket.on('chatMessage', (message) => displayMessage(message, 'peer'));

</script>

</body>
</html>
