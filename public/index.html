<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time WebRTC Chat</title>
    <link href='https://fonts.googleapis.com/css?family=Outfit' rel='stylesheet'>
    <style>
        body {
            font-family: 'Outfit'; font-size: 22px;
            margin: 0;
            padding: 0;
            height: 100vh;
            background: #e9e9e9;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            flex-direction: column;
        }

        #messages {
            font-size: 30px;
            padding: 20px;
            text-align: center;
            overflow-y: auto;
            max-height: 70vh;
            width: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .message {
            margin-bottom: 12px;
            padding: 12px;
            max-width: 90%;
            font-size: 40px;
            color: white;
            opacity: 0;
            display: inline-block;
            width: 0;
            overflow: hidden;
            transition: width 1s ease-out, opacity 1s ease-out;
        }

        .message.you {
            text-align: center;
             color:  black;
        }

        .message.peer {
            text-align: center;
             color:  black;
        }
 
        #messageInput {
            padding: 15px 30px;
            background: linear-gradient(to right, #ff7e5f, #feb47b);
            color: white;
            font-size: 18px;
            border: none;
            border-radius: 30px;
            outline: none;
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <h5 style="color:#cccccc; text-align: left;">Real-Time WebRTC Chat</h5>
    <div id="messages"></div>
    <input type="text" id="messageInput" placeholder="Type a message..." />

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io(); // Connect to the signaling server
        const peerConnection = new RTCPeerConnection();
        let dataChannel;
        const messagesDiv = document.getElementById("messages");
        const messageInput = document.getElementById("messageInput");

        let currentMessageDiv = null;  // Track the current message div

        // Display or update a message with the left-to-right fade-in effect
        function displayMessage(message, sender) {
            if (currentMessageDiv) {
                // Fade-out the previous message if it exists
                currentMessageDiv.style.transition = "opacity 1s ease-out";
                currentMessageDiv.style.opacity = 0;
            }

            // Create a new message div only if there's no existing message
            if (!currentMessageDiv) {
                currentMessageDiv = document.createElement("div");
                currentMessageDiv.classList.add("message");
                currentMessageDiv.classList.add(sender); // Apply different classes for sender/peer
                messagesDiv.appendChild(currentMessageDiv);
            }

            // Add sender label ("You" or "They")
            currentMessageDiv.textContent = (sender === 'you' ? 'You: ' : 'They: ') + message;

            // Apply the left-to-right fade-in effect
            setTimeout(() => {
                currentMessageDiv.style.width = "100%";  // Expand the text box
                currentMessageDiv.style.opacity = 1;     // Fade in the text
            }, sender === 'peer' ? 500 : 10);  // Add delay for peer messages

            // Auto-scroll to the bottom if the message is the last one
            const shouldScroll = messagesDiv.scrollHeight === messagesDiv.scrollTop + messagesDiv.clientHeight;
            if (shouldScroll) {
                messagesDiv.scrollTop = messagesDiv.scrollHeight; // Scroll to bottom
            }
        }

        // Create the data channel for WebRTC messaging
        function createDataChannel() {
            dataChannel = peerConnection.createDataChannel("chat");
            dataChannel.onopen = () => console.log("Data channel open.");
            dataChannel.onmessage = (event) => displayMessage(event.data, 'peer');
        }

        // Emit message when user types
        messageInput.addEventListener('input', () => {
            const message = messageInput.value.trim();
            if (message) {
                displayMessage(message, 'you'); // Show message locally
                socket.emit('chatMessage', message); // Emit to server
            }
        });

        // Clear messages when "Enter" is pressed
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                messageInput.value = ''; // Clear input field
                socket.emit('clearMessage'); // Notify server to clear messages
                clearMessagesWithEffect(); // Apply fade-out effect
            }
        });

        // Handle clearing of messages with fade-out effect
        function clearMessagesWithEffect() {
            if (currentMessageDiv) {
                currentMessageDiv.style.transition = "opacity 1s ease-out";
                currentMessageDiv.style.opacity = "0"; // Fade-out effect
                setTimeout(() => {
                    // Wait for fade-out to complete before clearing
                    currentMessageDiv.textContent = ''; // Clear message
                }, 1000); // Wait for the fade-out to complete
            }
        }

        // WebRTC signaling logic
        socket.on("offer", (offer) => {
            peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            createDataChannel();
            peerConnection.createAnswer().then((answer) => {
                peerConnection.setLocalDescription(answer);
                socket.emit("answer", answer);
            });
        });

        socket.on("answer", (answer) => {
            peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        });

        socket.on("candidate", (candidate) => {
            peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        });

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit("candidate", event.candidate);
            }
        };

        // Start WebRTC connection
        function initiateConnection() {
            peerConnection.createOffer().then((offer) => {
                peerConnection.setLocalDescription(offer);
                socket.emit("offer", offer);
            });
        }

        window.onload = initiateConnection;

        // Listen for chat messages from the other peer
        socket.on('chatMessage', (message) => displayMessage(message, 'peer'));
    </script>
</body>
</html>
